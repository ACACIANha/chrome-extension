#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# A simple native messaging host. Shows a Tkinter dialog with incoming messages
# that also allows to send message back to the webapp.
import struct
import sys
import threading

import logging

import json
import os
import subprocess

import tkinter

from queue import Queue

logging.basicConfig(filename='./info.log', level=logging.INFO)
logging.basicConfig(filename='./debug.log', level=logging.DEBUG)
logging.info('sys.platform : ' + sys.platform)

# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
    import os, msvcrt

    msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
    msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)


# Helper function that sends a message to the webapp.
def send_message(message):
    # Write message size.
    sys.stdout.write(struct.pack('I', len(message)))
    # Write the message itself.
    sys.stdout.write(message)
    sys.stdout.flush()


def send_message_string_to_json(message):
    tempString = {
        "text": message
    }
    tempJson = json.dumps(tempString)
    logging.info('send_message_string_to_json' + tempJson)
    send_message(tempJson)


# Thread that reads messages from the webapp.
def read_thread_func(queue):
    while 1:
        # Read the message length (first 4 bytes).
        text_length_bytes = sys.stdin.read(4)

        if len(text_length_bytes) == 0:
            logging.info('close')
            send_message_string_to_json("lengh is 0")
            if queue:
                queue.put(None)
            sys.exit(0)

        # Unpack message length as 4 byte integer.
        text_length = struct.unpack('i', text_length_bytes)[0]

        # Read the text (JSON object) of the message.
        text = sys.stdin.read(text_length).decode('utf-8')
        logging.info('read message' + text)

        y = json.loads(text)
        path = y["text"]
        openCommand5 = 'open /Applications/'
        openCommand7 = '.app'

        num = os.system(openCommand5 + path + openCommand7)

        tempText = "default"
        if num == 0:
            tempText = "success"
        else:
            tempText = "fail"

        send_message_string_to_json(tempText)

        if queue:
            queue.put(text)
        else:
            # In headless mode just send an echo message back.
            send_message('{"echo": %s}' % text)


if tkinter:
    class NativeMessagingWindow(tkinter.Frame):
        def __init__(self, queue):
            self.queue = queue

            tkinter.Frame.__init__(self)
            self.pack()
            self.after(100, self.processMessages)

        def processMessages(self):
            logging.debug('processMessages method')

            while not self.queue.empty():
                message = self.queue.get_nowait()
                if message == None:
                    self.quit()
                    return

            self.after(100, self.processMessages)


def Main():
    if not tkinter:
        logging.error('not found tkinter')
        send_message_string_to_json("error")
        send_message('"tkinter python module wasn\'t found. Running in headless ' +
                     'mode. Please consider installing Tkinter."')
        read_thread_func(None)
        sys.exit(0)

    logging.info('found tkinter')
    queue = Queue()
    logging.info('queue generate success')

    main_window = NativeMessagingWindow(queue)
    logging.info('window generate success')
    main_window.master.title('Native Messaging Example')

    thread = threading.Thread(target=read_thread_func, args=(queue,))
    thread.daemon = True
    thread.start()
    logging.info('thread generate and start success')

    main_window.mainloop()

    sys.exit(0)


if __name__ == '__main__':
    Main()
